{"meta":{"title":"casun","subtitle":"吹牛逼","description":null,"author":"Casun","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-10-30T15:44:23.000Z","updated":"2019-10-30T15:46:07.803Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-30T15:42:27.000Z","updated":"2019-10-30T15:43:39.831Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ArrayList源码分析","slug":"ArrayList源码分析","date":"2019-12-07T04:50:29.000Z","updated":"2019-12-07T04:51:43.112Z","comments":true,"path":"2019/12/07/ArrayList源码分析/","link":"","permalink":"http://yoursite.com/2019/12/07/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"ArrayList源码分析几个属性 elementData：存放数组 默认为空 minCapacity：最小存放容量，默认 DEFAULT_CAPACITY = 10 size：数组容量 MAX_ARRAY_SIZE：最大数组容量等于 Integer.MAX_VALUE - 8 几个函数 grow()：扩容函数 12345678910111213private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //所扩容容量为原容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); //分配数组空间&#125; hugeCapacity()：大容量处理1234567private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 当newCapacity 大于 MAX_ARRAY_SIZE 时进入该函数，判断应该返回什么新容量，通过 minCapacity 与 MAX_ARRAY_SIZE 的比值进行判断:如果大于则为 Integer.MAX_VALUE，否则为 MAX_ARRAY_SIZE。 ArrayList 扩容机制 ArrayList 的扩容主要发生在add()函数中 add() 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 第一步，先执行 ensureCapacityInternal(size + 1) 确保集合添加容量大于等于 size + 1,然后在数组elementData中添加元素。 ensureCapacityInternal() 1234567private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125; 第二步，在函数 ensureCapacityInternal() 中，如果数组elementData为空，则扩容容量为DEFAULT_CAPACITY = 10，然后执行ensureExplicitCapacity(minCapacity) 函数 ensureExplicitCapacity() 1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 第三步，在函数 ensureExplicitCapacity() 中，先将修改计数器加一modCount++，在判断是否需要扩容，如果需要执行grow() ArrayList与LinkedList的区别 数据结构：ArrayList 底层使用的是Object数组；LinkedList 底层使用的是双向链表数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！） 线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全。 插入和删除是否受元素位置的影响： ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话add(int index, E element)时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后(n-i)个元素都要执行向后位/向前移一位的操作。 LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O(1) 而数组为近似 O(n)。 是否支持快速随机访问：LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。 内存空间占用：ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"最大子序列和","slug":"最大子序列和","date":"2019-10-31T03:19:56.000Z","updated":"2019-10-31T03:24:50.526Z","comments":true,"path":"2019/10/31/最大子序列和/","link":"","permalink":"http://yoursite.com/2019/10/31/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/","excerpt":"","text":"最大子序列和题目描述 给出一段序列，选出其中连续且非空的一段使得这段和最大。 方法一 分治法123456789101112131415161718192021222324252627282930313233int divide(int a[],int left,int right)&#123; int mid =(left+right)/2; if(right==left) return a[left]; int max_left_sum=divide(a,left,mid);//左字段最大和 int max_right_sum=divide(a,mid+1,right);//右字段最大和 //处理端点分别在左半段和右半段的情况 int sum=0; int left_sum=-10001; for(int i=mid;i&gt;=left;--i) &#123; sum+=a[i]; if(sum&gt;left_sum) left_sum=sum; &#125; sum=0; int right_sum=-10001; for(int i=mid+1;i&lt;=right;++i) &#123; sum+=a[i]; if(sum&gt;right_sum) right_sum=sum; &#125; int max_mid_sum=left_sum+right_sum; int max=max_mid_sum; if(max&lt;max_left_sum)//求三者最大值 max=max_left_sum; if(max&lt;max_right_sum) max=max_right_sum; return max;&#125; 方法二 动态规划12345678910111213141516int dp(int a[],int n)//状态转移方程 f[i]=max(f[i-1]+a[i],a[i])/***因为若f[i]的值为负数，则f[i+1]的值就是n[i],而n[i]的值不一定比前面的最大字段和数大！**或者n[i]为负数，则f[i]小于f[i-1]!**所以，我们还要再用一个数从1到n再查找一次，才能找出最大数.*/&#123; int ans[200005]=&#123;0&#125;; int sum=-10001; for(int i=0;i&lt;n;i++) &#123; ans[i]=max(ans[i-1]+a[i],a[i]); sum=max(sum,ans[i]); &#125; return sum;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"test","slug":"test","date":"2019-10-31T02:51:16.000Z","updated":"2019-10-31T03:02:59.257Z","comments":true,"path":"2019/10/31/test/","link":"","permalink":"http://yoursite.com/2019/10/31/test/","excerpt":"","text":"First title1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun(); Second title 这是引用","categories":[{"name":"categories1","slug":"categories1","permalink":"http://yoursite.com/categories/categories1/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"http://yoursite.com/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"http://yoursite.com/tags/tag2/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-10-30T15:04:19.600Z","updated":"2019-10-30T15:04:19.600Z","comments":true,"path":"2019/10/30/hello-world/","link":"","permalink":"http://yoursite.com/2019/10/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}